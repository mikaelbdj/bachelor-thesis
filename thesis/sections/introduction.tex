\documentclass[../master/master.tex]{subfiles}

\begin{document}
Graphs are one of the cornerstones in computer science when it comes to representing the models we work with. They are used in data organization,  program compilation (registry allocation etc.), networks of communication and in particular model checking.

One of the main obstacles in model checking is so called \textit{state explosion}, where the state space grows exponentially in the size of the model. Thus, model checking often has to deal with extremely large graphs \cite{pelanek_2004}. As our model size increases, running an algorithm on the resulting graph quickly becomes infeasible as we cannot store the graph or the computations in memory. A solution to this problem is to find a more concise representation of graphs - one that does not have an exponential increase in storage usage, even if the graph size increases exponentially. One such representation is a binary decision diagram as described in \cite{bryant_1992} - these can be used to represent boolean functions and thus relations. Representing relations is all we need if we view a graph as a set of edges.

The two papers \cite{linear} and \cite{lockstep} presents algorithms working on such a graph representation - so called symbolic algorithms. The papers in question investigate algorithms that center around the computation of strongly connected components on symbolically represented graphs. Efficient computation of strongly connected components is very relevant in the field of model checking, for example for deciding emptines of Büchi automata - in \cite{lockstep} the proposed Lockstep algorithm is used to decide Büchi emptiness.  For strongly connected components in particular, we cannot just reuse conventional SCC algorithms that work for explicit graph representations (such as Robert Tarjan's famous linear algorithm \cite{tarjan_1971}). The reason is that this involves computing a spanning forest of the graph - ie. performing a depth-first search. A DFS is simply not possible on a symbolically reperesented graph, as it involves considering and labeling each node individually - something that is obviously impossible to do unless the graph is explicitly represented. Thus, in a symbolic setting our options are more limited; our main tool is the computation of the image and pre-image over sets of nodes. Such a computation is refered to as a symbolic step and time complexity in symbolic algorithms is normally measured in these.

The papers previously mentioned (\cite{linear} and \cite{lockstep}) presented symbolic SCC decomposition algorithms with respective time complexities of $\mathcal{O}(n)$ and  $\mathcal{O}(n \log n)$. However, these time complexities does not necessarily reflect practical efficiency. For example, the average symbolic step in the linear algorithm (\cite{linear}) might be more time consuming, or the asymptotic advantage that linear has over lockstep does not outweigh the constants hidden in the $\mathcal{O} $-notation for practical applications. 

Thus, the purpose of this thesis is to examine the practical difference between the two algorithms. This is done by firstly implementing a small framework that can represent graphs as BDDs, building on top of the JavaBDD package \cite{whaley}. This framework facilitates the implementation of algorithms using a common API for performing symbolic operations and BDD operations; this allows a controlled comparison of them. 
When comparing, we ran the different algorithms on the same collection of graphs of varying size and structure.

We suggest a few improvements that could be made to the two proposed algorithms - these will also be included in our experiments. One such improvement is \textit{trimming}, introduced in \cite{lockstep}, which we apply to both linear and lockstep. In total we examine 5 algorithms for SCC decomposition, including the two original algorithms. The results will be analyzed with respect to the amount of symbolic steps taken and with respect to the practical runtime of the algorithms. The final conclusions we draw will rely heavily on the latter, as we want to investigate the practical difference between the algorithms.

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../master/master"
%%% End:
