\documentclass[../master/master.tex]{subfiles}

\begin{document}
Graphs are one of the cornerstones in computer science when it comes to representing the models we work with. 

They are used in data organization,  program compilation (registry allocation etc.), networks of communication and in particular model checking. One of the main obstacles in model checking is so called \textit{state explosion}, where the state space grows exponentially in the size of the model. Thus, model checking often has to deal with extremely large graphs \cite{pelanek_2004}. As our model size increases, running an algorithm on the resulting graph quickly becomes infeasible as we cannot store the graph or the computations in memory. A solution to this problem is to find a more concise representation of graphs - one that does not have an exponential increase in storage usage even if the graph size increases exponentially. One such representation is a binary decision diagram as described in \cite{bryant_1992} - these can be used to represent boolean functions and thus relations. Representing relations is all we need if we view a graph as a set of edges. The two papers \cite{linear} and \cite{lockstep} presents algorithms working on such a graph representation - so called symbolic algorithms. The papers in question investigate algorithms that centers around the computation of strongly connected components on symbolically represented graphs. For strongly connected components in particular we cannot just reuse conventional SCC algorithms that work for explicit graph reperesentations (such as Robert Tarjan's famous linear algorithm \cite{tarjan_1971}). The reason is, that this involves computing a spanning forrest of the graph - ie. performing a depth-first search. A DFS is simply not possible on a symbolically reperesented graph, as it involves considering and labelling each node individually - something that is obviously impossible to do unless the graph is explicitly represented. Thus, in a symbolic setting our options are more limited; our main tool is the computation of the image and pre-image over sets of nodes. Such a computation is refered to as a symbollic step and time complexity in symbollic algorithms is normally measured in these.

The papers previously mentioned (\cite{linear} and \cite{lockstep}) presented symbolic SCC decomposition algorithms with respective time complexities of $\mathcal{O}(n \log n)$ and $\mathcal{O}(n)$. The lockstep algorithm (\cite{lockstep})\todo{cite this} seem to be the generally used solution , even though its symbolic time complexity has a higher upperbound. This might be due to that the average symbollic step in the linear algorithm (\cite{linear}) is more time consuming, or that the the asymptotic advantage that linear has over lockstep does not outweigh the constants hidden in the $\mathcal{O} $-notation for practical applications.

The purpose of this paper is to examine the practical difference between these two algorithms. This is done by firstly implementing a small framework that can represent graphs as BDDs, building on top of the JavaBDD package \cite{whaley}. This framework facilitates the implementation of algorithms using a common API for performing symbolic operations and BDD operations; this allows a controlled comparison of them. 
\end{document}