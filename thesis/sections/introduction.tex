\documentclass[../master/master.tex]{subfiles}

\begin{document}
Graphs are one of the cornerstones in computer science when it comes to representing the models we work with. 

They are used in data organization,  program compilation (registry allocation etc.), networks of communication and in particular model checking. One of the main obstacles in model checking is so called \textit{state explosion}, where the state space grows exponentially in the size of the model. Thus, model checking often has to deal with extremely large graphs \cite{pelanek_2004}. As our model size increases, running an algorithm on the resulting graph quickly becomes infeasible as we cannot store the graph or the computations in memory. A solution to this problem is to find a more concise representation of graphs - one that does not have an exponential increase in storage usage even if the graph size increases exponentially. One such representation is a binary decision diagram as described in \cite{bryant_1992} - these can be used to represent boolean functions and thus relations. Representing relations is all we need if we view a graph as a set of edges. The two papers \cite{linear} and \cite{lockstep} presents algorithms working on such a graph representation - so called symbolic algorithms. The papers in question investigate algorithms that centers around the computation of strongly connected components on symbolically represented graphs. For strongly connected components in particular we cannot just reuse conventional SCC algorithms that work for explicit graph reperesentations (such as Robert Tarjan's famous linear algorithm \cite{tarjan_1971}). The reason is, that this involves computing a spanning forrest of the graph - ie. performing a depth-first search. A DFS is simply not possible on a symbolically reperesented graph, as it involves considering and labelling each node individually - something that is obviously impossible to do unless the graph is explicitly represented. 

The papers previously mentioned (\cite{linear} and \cite{lockstep}) produced symbolic SCC decomposition algorithms with respective time complexities of $O(n \log n)$ and $O(n)$.
\end{document}