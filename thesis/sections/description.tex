\documentclass[../master/master.tex]{subfiles}

\begin{document}
\subsection{Lockstep}
The first algorithm we will be looking at is the Lockstep algorithm proposed by Bloem et al. \cite{lockstep} The Lockstep algorithm performs forward and backward search simultaneously and recurses after removal of the SCC in each iteration.

We have modified this algorithm slightly, as we do not look at Streett automata, and are therefore not interested in the Report function introduced in the article. For the same reason, we also modified the input of the algorithm to only take a graph and a set of vertices. 

We start by initializing the set $P=V$ in the first iteration, for which we will be finding SCCs. During the iterations, this set will be modified, and once it is empty, we return, as no SCCs exist in an empty set. The algorithm then initializes the forward and backward sets \FW{v} and \BW{v} of some node, as well as their frontiers, which are all initially set to $v\in G$ - the singleton set of a node picked from $P$.

The next step is simultaneously performing forward and backward set computations until either \FW{v} or \BW{v} converges. This is done by extending the forward and backward frontiers by taking their image and preimage respectively, selecting only those of the nodes, which are in our current $P$ and finally removing all the nodes which already exist in \FW{v} and \BW{v} respectively. We then update the values of \FW{v} and \BW{v} to include the elements that we have found in their respective frontiers. This is done in iterations until either of the frontiers is an empty set, meaning that it will no longer be updated.
In other words, by iteratively computing the two functions (\ref{fw}) and (\ref{bw}) until one of them reaches its least fixpoint. The forward or backward set with the empty frontier is then set as \emph{Converged}. This is essential for obtaining the $n$\,log\,$n$ bound that will be examined later on.

Once one of the sets has converged, we continue updating the other set, just like before until its frontier has no nodes in common with the \emph{Converged} set. \todo{probably a good idea to add why this is}
We have now found a SCC, which is the nodes in $\FW{v}\cap\BW{v}$. \todo{again, expand}

We recursively call Lockstep on the set of vertices in $P\setminus Converged$. Here, we don't check for strongly connected components in the \emph{Converged} set, and therefore we also call the Lockstep procedure on this set of nodes, once we have removed the SCC from it.

\begin{algorithm}
  \caption{Lockstep((V, E), P $\subseteq$ V)}
  \begin{algorithmic}[1]
    \Statex
    \If{$P=\emptyset$}
     \State \Return $\emptyset$
    \EndIf
    \Statex
    \Let{$v$}{pick($P$)}
    \Let{$FW, BW$, Ffront, Bfront}{$\set{v}$}
    \Statex
    \While{Ffront$\neq\emptyset$ \textbf{and} Bfront$\neq\emptyset$}
     \Let{Ffront}{$\text{img(Ffront)}\cap P\setminus FW$}
     \Let{Bfront}{$\text{preimg(Bfront)}\cap P\setminus BW$}
     \Let{$FW$}{$FW\cup\text{Ffront}$}
     \Let{$BW$}{$BW\cup\text{Bfront}$}
    \EndWhile
    \Statex
    \If{Ffront$=\emptyset$}
     \Let{$Converged$}{$FW$}
    \Else
     \Let{$Converged$}{$BW$}
    \EndIf
    \Statex
    \While{$\text{Ffront}\cap BW\neq\emptyset$ \textbf{or} $\text{Bfront}\cap FW\neq\emptyset$}
     \Let{Ffront}{$\text{img(Ffront)}\cap P\setminus FW$}
     \Let{Bfront}{$\text{preimg(Bfront)}\cap P\setminus BW$}
     \Let{$FW$}{$FW\cup\text{Ffront}$}
     \Let{$BW$}{$BW\cup\text{Bfront}$}
    \EndWhile
    \Statex
    \Let{$C$}{$FW\cap BW$}
    \Let{SCCset1}{Lockstep($(V, E)$, $Converged\setminus C$)}
    \Let{SCCset2}{Lockstep($(V, E)$, $P\setminus Converged$)}
    \Let{SCCs}{$\set{C}\cup \text{SCCset1} \cup \text{SCCset2}$}
    \State \Return SCCs
  \end{algorithmic}
\end{algorithm}
This algorithm takes $O(n\ log\ n)$ time. Argue. Bloem p.47 
\subsection{Linear-time algorithm}
The second algorithm we will be comparing is the linear-time algorithm \cite{linear} introduced by Gentilini et al. This algorithm takes as input a graph G and spine-set $\langle S, N\rangle$. In the paper, the algorithm outputs vertex sets of SCC subgraphs, however here we change this to return a set of SCCs, similarly to the Lockstep algorithm.

The first thing the algorithm does, is to choose for which vertex the next SCC will be computed, unless $V=\emptyset$, in which case the algorithm terminates. If $S\neq\emptyset$ and $N={v_p}$, then $v_p$ is chosen. Otherwise, an arbitrary $v$ is assigned to N.

Next, \FW{N} and a skeleton \pair{S'}{N'} on this forward-set is computed. The next step is to determine the SCC containing N.\todo{describe how this is done} The SCCs, which is our set of SCCs, is then extended by the SCC that the algorithm has just found.

Once this is done, this procedure is called recursively on two subgraphs. The first recursive call is on the subgraph $V\setminus FW$ (its vertices and edges) as well as its spine-set, obtained by removing the SCC from the spine-set \pair{S}{N}. We then recurse again on a second subgraph, $FW\setminus SCC$ and its spine-set, \pair{newS}{newN}, which we found by computing the skeleton of $(V, E, N)$.

\begin{algorithm}[h!]
  \caption{Linear((V, E), \pair{S}{N})}
  \begin{algorithmic}[1]
    \If{$V=\emptyset$}
     \State \Return
    \EndIf
    \Statex
    \If{$S=\emptyset$}
      \Let{$N$}{pick($V$)}
    \EndIf
    \Statex
    \Let{$\langle FW, newS, newN\rangle$}{skelForward($V, E, N$)}
    \Statex
    \Let{$SCC$}{$N$}
    \While{$\text{preimg}(SCC)\cap FW)\setminus SCC)\neq\emptyset$}
     \Let{$SCC$}{$SCC\cup (\text{preimg}(SCC)\cap FW)$}
    \EndWhile
    \Statex
    \Let{$V'$}{$V\setminus FW$}
    \Let{$E'$}{$E\upharpoonright V'$}
    \Let{$S'$}{$S\setminus SCC$}
    \Let{$N'$}{$\text{preimg}(SCC\cap S)\cap(S\setminus SCC)$}
    \Let{SCCset1}{Linear($(V', E')$, \pair{S'}{N'})}
    \Statex
    \Let{$V'$}{$FW\setminus SCC$}
    \Let{$E'$}{$E\upharpoonright V'$}
    \Let{$S'$}{$newS\setminus SCC$}
    \Let{$N'$}{$newN\setminus SCC$}
    \Let{SCCset2}{Linear($(V', E')$, \pair{S'}{N'})}
    \Statex
    \Let{SCCs}{$\set{SCC}\cup \text{SCCset1} \cup \text{SCCset2}$}
    \State \Return SCCs
  \end{algorithmic}
\end{algorithm}
\todo{missing parantheses in while loop and in skelforward}

The skelForward algorithm is a helper method introduced by Gentilini et al., which computes the forward set of the given graph and the skeleton of this set. This results in the spine-set of the given graph.

\begin{algorithm}[H]
  \caption{SkelForward((V, E), N)}
  \begin{algorithmic}[1]
    \Let{$L$}{$N$}
    \Statex
    \While{$L\neq \emptyset$}
    \State push(stack, $L$)
    \Let{$FW$}{$FW\cup L$}
    \Let{$L$}{post($L$)$\setminus FW$}
    \EndWhile
    \Statex
    \Let{$L$}{pop(stack)}
    \State $S' \gets N' \gets pick(L)$
    \While{stack $\neq\emptyset$}
    \Let{$L$}{pop(stack)}
    \Let{$S'$}{$S'\cup\text{pick(pre(}S')\cap L$}
    \EndWhile
    \Statex
    \State \Return $\langle FW, S', N' \rangle$
  \end{algorithmic}
\end{algorithm}
\subsection{Complexity}
Here we analyze the complexity of the two algorithms. We state the results in \label{linear}
\begin{theorem}\label{linear} Linear($V, E, \pair{\emptyset}{\emptyset}$) runs in $O(|V|)$ symbolic steps.
\end{theorem}
\begin{proof} A constant number of steps is performed in lines 1-4 and 9-18, as here we call preImg once when calculating the new $N'$ for SCCset1. Each recursive call in the pseudocode (or each iterative call in our implementation) returns an SCC, and since there are at most as many SCCs as there are nodes, we can deduce that over all iterations in lines 1-4 and 9-18, the algorithm performs $O(|V|)$ symbolic steps.

Next, in lines 7-8, nodes are assiged to our SCC. Since each node can be part of at most one SCC, we can also deduce that this part of the algorithm also performs $O(|V|)$ symbolic steps globally.

Lastly, we have the call to skelForward in line 5, which performs the remaining symbolic steps. Here, the number of symbolic steps is the number of elements popped from the stack in skelForward before the termintion of the second recursive call in the pseudocode, or before all node sets are popped from our implementartion of the algorithm. Since each $v\in V$ is inserted into a spine-set at most two times within Linear($V, E, \pair{S}{N}$)\cite{linear}\todo{add page number to Lemma 12}, we know that it will take at most $2|V|$ symbolic steps globally, and thereofore we also achieve the $O(|V|)$ bound for this part.

Given that each of the different parts perform $O(|V|)$ symbollic steps globally, we can conclude that the algorithm runs in $O(|V|)$ symbolic steps.
\end{proof}
\todo{add corollary 1 ?}
\todo{add small example that shows difference between two algorithms}
\todo{make sure that the variable names are consistent}
\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../master/master"
%%% End:
