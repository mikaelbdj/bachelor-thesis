\documentclass[../master.tex]{subfiles}
\newcommand{\FW}[2][G]{\ensuremath{FW_{#1}(#2)}}
\newcommand{\BW}[2][G]{\ensuremath{BW_{#1}(#2)}}
\newcommand{\pair}[2]{\ensuremath{\langle #1, #2\rangle}}

\begin{document}
\subsection{Preliminaries}
 For the following definitons, let $G=(V,E)$ be a digraph.
\todo[inline]{add intuitive definition first, before in depth}
The key elements of the algorithm are forward and backward sets. Let $U\subseteq V$. A forward set, \FW{U}, is the set of nodes that can be reached from U. Similarily, a backward set, \BW{U}, is a set if all the nodes that reach U.

A skeleton of a forward set of the vertex $v$ \FW{v} is $\langle S, v \rangle$, iff the distance from $v$ to $u$ is maximum and $S$ is the set of nodes on the shortest path between the two vertices

The authors of this algorithm introduce the notion of a spine-set, whih is a symbolic way of ordering sets of nodes. A spine-set is a subset $\langle S, v\rangle$ of a graph $G=(V,E)$, such that $S\subseteq V$, for which G contains a chordless path for the set $S$ ending in $v$.

\subsection{Lockstep}
The first algorithm we will be looking at is the Lockstep alagorithm proposed by Bloem et al. \cite{lockstep} The Lockstep algorithm performs forward and backward search simultaneously and recurses after removal of the SCC in each iteration.
\todo{add something about no no report as we don't look at street and all sccs are fair???}
We start by initializing the set $P=V$, for which we will be finding SCCs. During the iterations, this set will be modified, and once it is empty, we return, as no SCCs exist in an empty set. The algorithm then initializes the forward and backward sets \FW{v} and \BW{v}, as well as their frontiers, which are all initially set to a singleton, which the algorithm picks from $P$.
The next step is simultaneosuly performing forward and backward searches until either \FW{v} or \BW{v} converges. This is done by extending the forward and backward frontiers by  taking their image and preimage respectively, selecting only those of the nodes, which are in our current $P$ and finally removing all the nodes which already exist in \FW{v} and \BW{v} respectively. \todo{maybe add what preimage and image do?}. We then update the values of \FW{v} and \BW{v} to include the elements that we have found in the respective frontiers. This is done in iterations until either of the frontiers is an empty set, meaning that it will no longer be updated. The forward or backward set corresponding frontier is then set as \texttt{Converged}.
Once one of the sets has converged, we repeat updating the forward and backward frontiers and sets, just like before until either the forward frontier and backward set or backward frontier and forward set have no nodes in common. \todo{add explanation for why this is}.
We have now found a SCC, which is the nodes in $\FW{v}\cap\BW{v}$.
We recursively call Lockstep on the set of vertices in $P\setminus Converged$. Here we don't check for strongly connected components in the \texttt{Converged} set, and therefore we also call the Lockstep procedure on this set of nodes, once we have removed the SCC from it.

\subsection{Linear time algorithm}
The second algortihm we will be comparing is the linear time algorithm \cite{linear} introduced by Gentilini et al. This algorithm takes as input a graph G and spine-set $\langle S, N\rangle$ and outputs vertex sets of SCC subgraphs.

The first thibng the algorithm does, is to choose for which vertex the next SCC will be computed, unless $V=\empty$, in which case the algorithm terminates. If $S\neq\empty$, and $N={v_p}$, $v_p$ is chosen. Otherwise, an arbitrary v is assigned to N. Next, \FW{N} and a skeleton \pair{S'}{u'} on this forward-set is computed.The next stpe is to determine the SCC containing N.\todo{describe how this is done}. Once this SCC has been added to the SCC partition \todo{explain SCC partition?}
Once this is done, this procedure is called recursively on two subgraphs. The first recursive call is on the subgraph V\textbackslash FW (its vertices and edges) as well as its spine-set, obtained by removing the SCC from the spine-set $\langle S, N\rangle$. We then recurse again on a second subgraph, FW\textbackslash SCC and its spine-set, which we have computed previously, namely \pair, which we found by computing the skeleton of (V, E, N).

\todo[inline]{is preimage the same as pre here?}
\todo[inline]{add small example that shows difference between two algorithms}
\todo[inline]{check def of preimage in lockstep and compare to pre in linear, also look at the forward set definition, maybe write it down some place so that there is access to it}

\todo[inline]{rewrite pseudocode for the two algorithms}

\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../master/master"
%%% End:
